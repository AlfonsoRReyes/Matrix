\hypertarget{R__ldl_8c}{
\subsection{R\_\-ldl.c File Reference}
\label{R__ldl_8c}\index{R_ldl.c@{R\_\-ldl.c}}
}
{\tt \#include \char`\"{}R\_\-ldl.h\char`\"{}}\par
\subsubsection*{Functions}
\begin{CompactItemize}
\item 
void \hyperlink{R__ldl_8c_a0}{R\_\-ldl\_\-symbolic} (int n, const int Ap\mbox{[}$\,$\mbox{]}, const int Ai\mbox{[}$\,$\mbox{]}, int Lp\mbox{[}$\,$\mbox{]}, int Parent\mbox{[}$\,$\mbox{]}, const int P\mbox{[}$\,$\mbox{]}, int Pinv\mbox{[}$\,$\mbox{]})
\item 
int \hyperlink{R__ldl_8c_a1}{R\_\-ldl\_\-numeric} (int n, const int Ap\mbox{[}$\,$\mbox{]}, const int Ai\mbox{[}$\,$\mbox{]}, const double Ax\mbox{[}$\,$\mbox{]}, const int Lp\mbox{[}$\,$\mbox{]}, const int Parent\mbox{[}$\,$\mbox{]}, int Li\mbox{[}$\,$\mbox{]}, double Lx\mbox{[}$\,$\mbox{]}, double D\mbox{[}$\,$\mbox{]}, const int P\mbox{[}$\,$\mbox{]}, const int Pinv\mbox{[}$\,$\mbox{]})
\item 
void \hyperlink{R__ldl_8c_a2}{R\_\-ldl\_\-lsolve} (int n, double X\mbox{[}$\,$\mbox{]}, const int Lp\mbox{[}$\,$\mbox{]}, const int Li\mbox{[}$\,$\mbox{]}, const double Lx\mbox{[}$\,$\mbox{]})
\item 
void \hyperlink{R__ldl_8c_a3}{R\_\-ldl\_\-dsolve} (int n, double X\mbox{[}$\,$\mbox{]}, const double D\mbox{[}$\,$\mbox{]})
\item 
void \hyperlink{R__ldl_8c_a4}{R\_\-ldl\_\-ltsolve} (int n, double X\mbox{[}$\,$\mbox{]}, const int Lp\mbox{[}$\,$\mbox{]}, const int Li\mbox{[}$\,$\mbox{]}, const double Lx\mbox{[}$\,$\mbox{]})
\item 
void \hyperlink{R__ldl_8c_a5}{R\_\-ldl\_\-perm} (int n, double X\mbox{[}$\,$\mbox{]}, const double B\mbox{[}$\,$\mbox{]}, const int P\mbox{[}$\,$\mbox{]})
\item 
void \hyperlink{R__ldl_8c_a6}{R\_\-ldl\_\-permt} (int n, double X\mbox{[}$\,$\mbox{]}, const double B\mbox{[}$\,$\mbox{]}, const int P\mbox{[}$\,$\mbox{]})
\item 
int \hyperlink{R__ldl_8c_a7}{R\_\-ldl\_\-valid\_\-perm} (int n, const int P\mbox{[}$\,$\mbox{]})
\item 
int \hyperlink{R__ldl_8c_a8}{R\_\-ldl\_\-valid\_\-matrix} (int n, const int Ap\mbox{[}$\,$\mbox{]}, const int Ai\mbox{[}$\,$\mbox{]})
\end{CompactItemize}


\subsubsection{Function Documentation}
\hypertarget{R__ldl_8c_a3}{
\index{R_ldl.c@{R\_\-ldl.c}!R_ldl_dsolve@{R\_\-ldl\_\-dsolve}}
\index{R_ldl_dsolve@{R\_\-ldl\_\-dsolve}!R_ldl.c@{R\_\-ldl.c}}
\paragraph[R\_\-ldl\_\-dsolve]{\setlength{\rightskip}{0pt plus 5cm}void R\_\-ldl\_\-dsolve (int {\em n}, double {\em X}\mbox{[}$\,$\mbox{]}, const double {\em D}\mbox{[}$\,$\mbox{]})}\hfill}
\label{R__ldl_8c_a3}


solve Dx=b

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]L is n-by-n, where n $>$= 0 \item[{\em X}]size n. right-hand-side on input, soln. on output \item[{\em D}]diagonal elements of size n \end{description}
\end{Desc}
\hypertarget{R__ldl_8c_a2}{
\index{R_ldl.c@{R\_\-ldl.c}!R_ldl_lsolve@{R\_\-ldl\_\-lsolve}}
\index{R_ldl_lsolve@{R\_\-ldl\_\-lsolve}!R_ldl.c@{R\_\-ldl.c}}
\paragraph[R\_\-ldl\_\-lsolve]{\setlength{\rightskip}{0pt plus 5cm}void R\_\-ldl\_\-lsolve (int {\em n}, double {\em X}\mbox{[}$\,$\mbox{]}, const int {\em Lp}\mbox{[}$\,$\mbox{]}, const int {\em Li}\mbox{[}$\,$\mbox{]}, const double {\em Lx}\mbox{[}$\,$\mbox{]})}\hfill}
\label{R__ldl_8c_a2}


solve Lx=b

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]L is n-by-n, where n $>$= 0 \item[{\em X}]size n. right-hand-side on input, soln. on output \item[{\em Lp}]column pointer array of size n+1 \item[{\em Li}]row index array of size lnz=Lp\mbox{[}n\mbox{]} \item[{\em Lx}]non-zero off-diagonal elements (size lnz=Lp\mbox{[}n\mbox{]}) \end{description}
\end{Desc}
\hypertarget{R__ldl_8c_a4}{
\index{R_ldl.c@{R\_\-ldl.c}!R_ldl_ltsolve@{R\_\-ldl\_\-ltsolve}}
\index{R_ldl_ltsolve@{R\_\-ldl\_\-ltsolve}!R_ldl.c@{R\_\-ldl.c}}
\paragraph[R\_\-ldl\_\-ltsolve]{\setlength{\rightskip}{0pt plus 5cm}void R\_\-ldl\_\-ltsolve (int {\em n}, double {\em X}\mbox{[}$\,$\mbox{]}, const int {\em Lp}\mbox{[}$\,$\mbox{]}, const int {\em Li}\mbox{[}$\,$\mbox{]}, const double {\em Lx}\mbox{[}$\,$\mbox{]})}\hfill}
\label{R__ldl_8c_a4}


solve L'x=b

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]L is n-by-n, where n $>$= 0 \item[{\em X}]size n. right-hand-side on input, soln. on output \item[{\em Lp}]column pointer array of size n+1 \item[{\em Li}]row index array of size lnz=Lp\mbox{[}n\mbox{]} \item[{\em Lx}]non-zero off-diagonal elements (size lnz=Lp\mbox{[}n\mbox{]}) \end{description}
\end{Desc}
\hypertarget{R__ldl_8c_a1}{
\index{R_ldl.c@{R\_\-ldl.c}!R_ldl_numeric@{R\_\-ldl\_\-numeric}}
\index{R_ldl_numeric@{R\_\-ldl\_\-numeric}!R_ldl.c@{R\_\-ldl.c}}
\paragraph[R\_\-ldl\_\-numeric]{\setlength{\rightskip}{0pt plus 5cm}int R\_\-ldl\_\-numeric (int {\em n}, const int {\em Ap}\mbox{[}$\,$\mbox{]}, const int {\em Ai}\mbox{[}$\,$\mbox{]}, const double {\em Ax}\mbox{[}$\,$\mbox{]}, const int {\em Lp}\mbox{[}$\,$\mbox{]}, const int {\em Parent}\mbox{[}$\,$\mbox{]}, int {\em Li}\mbox{[}$\,$\mbox{]}, double {\em Lx}\mbox{[}$\,$\mbox{]}, double {\em D}\mbox{[}$\,$\mbox{]}, const int {\em P}\mbox{[}$\,$\mbox{]}, const int {\em Pinv}\mbox{[}$\,$\mbox{]})}\hfill}
\label{R__ldl_8c_a1}


Given a sparse matrix A (the arguments n, Ap, Ai, and Ax) and its symbolic analysis (Lp and Parent, and optionally P and Pinv), compute the numeric LDL' factorization of A or PAP'. The outputs of this routine are arguments Li, Lx, and D.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]A and L are n-by-n, where n $>$= 0 \item[{\em Ap}]column pointer array of size n+1 \item[{\em Ai}]row index array of size nz=Ap\mbox{[}n\mbox{]} (upper triangle only) \item[{\em Ax}]array of non-zero matrix elements of size nz=Ap\mbox{[}n\mbox{]} \item[{\em Lp}]column pointer array of size n+1 \item[{\em Parent}]elimination tree of size n \item[{\em Li}]row index array of size lnz=Lp\mbox{[}n\mbox{]} \item[{\em Lx}]non-zero off-diagonal elements of L (size lnz=Lp\mbox{[}n\mbox{]}) \item[{\em D}]vector of diagonal elements (size n) \item[{\em P}]optional permutation vector of size n \mbox{[}use (int $\ast$) NULL for none\mbox{]} \item[{\em Pinv}]optional inverse permutation \mbox{[}use (int $\ast$) NULL for none\mbox{]}\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]n if successful, k if D (k,k) is zero \end{Desc}
\hypertarget{R__ldl_8c_a5}{
\index{R_ldl.c@{R\_\-ldl.c}!R_ldl_perm@{R\_\-ldl\_\-perm}}
\index{R_ldl_perm@{R\_\-ldl\_\-perm}!R_ldl.c@{R\_\-ldl.c}}
\paragraph[R\_\-ldl\_\-perm]{\setlength{\rightskip}{0pt plus 5cm}void R\_\-ldl\_\-perm (int {\em n}, double {\em X}\mbox{[}$\,$\mbox{]}, const double {\em B}\mbox{[}$\,$\mbox{]}, const int {\em P}\mbox{[}$\,$\mbox{]})}\hfill}
\label{R__ldl_8c_a5}


permute a vector, x=Pb

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]size of X, B, and P \item[{\em X}]output of size n \item[{\em B}]input of size n \item[{\em P}]input permutation array of size n \end{description}
\end{Desc}
\hypertarget{R__ldl_8c_a6}{
\index{R_ldl.c@{R\_\-ldl.c}!R_ldl_permt@{R\_\-ldl\_\-permt}}
\index{R_ldl_permt@{R\_\-ldl\_\-permt}!R_ldl.c@{R\_\-ldl.c}}
\paragraph[R\_\-ldl\_\-permt]{\setlength{\rightskip}{0pt plus 5cm}void R\_\-ldl\_\-permt (int {\em n}, double {\em X}\mbox{[}$\,$\mbox{]}, const double {\em B}\mbox{[}$\,$\mbox{]}, const int {\em P}\mbox{[}$\,$\mbox{]})}\hfill}
\label{R__ldl_8c_a6}


permute a vector, x=P'b

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]size of X, B, and P \item[{\em X}]output of size n \item[{\em B}]input of size n \item[{\em P}]input permutation array of size n \end{description}
\end{Desc}
\hypertarget{R__ldl_8c_a0}{
\index{R_ldl.c@{R\_\-ldl.c}!R_ldl_symbolic@{R\_\-ldl\_\-symbolic}}
\index{R_ldl_symbolic@{R\_\-ldl\_\-symbolic}!R_ldl.c@{R\_\-ldl.c}}
\paragraph[R\_\-ldl\_\-symbolic]{\setlength{\rightskip}{0pt plus 5cm}void R\_\-ldl\_\-symbolic (int {\em n}, const int {\em Ap}\mbox{[}$\,$\mbox{]}, const int {\em Ai}\mbox{[}$\,$\mbox{]}, int {\em Lp}\mbox{[}$\,$\mbox{]}, int {\em Parent}\mbox{[}$\,$\mbox{]}, const int {\em P}\mbox{[}$\,$\mbox{]}, int {\em Pinv}\mbox{[}$\,$\mbox{]})}\hfill}
\label{R__ldl_8c_a0}


The input to this routine is a sparse matrix A, stored in column form, and an optional permutation P. The output is the elimination tree and the number of nonzeros in each column of L. Parent \mbox{[}i\mbox{]} = k if k is the parent of i in the tree. The Parent array is required by R\_\-ldl\_\-numeric. Lnz \mbox{[}k\mbox{]} gives the number of nonzeros in the kth column of L, excluding the diagonal.

If P is NULL, then it is ignored. The factorization will be LDL' = A. Pinv is not computed. In this case, neither P nor Pinv are required by R\_\-ldl\_\-numeric.

If P is not NULL, then it is assumed to be a valid permutation. If row and column j of A is the kth pivot, the P \mbox{[}k\mbox{]} = j. The factorization will be LDL' = PAP', or A (p,p) in MATLAB notation. The inverse permutation Pinv is computed, where Pinv \mbox{[}j\mbox{]} = k if P \mbox{[}k\mbox{]} = j. In this case, both P and Pinv are required as inputs to R\_\-ldl\_\-numeric.

The floating-point operation count of the subsequent call to R\_\-ldl\_\-numeric is not returned, but could be computed after R\_\-ldl\_\-symbolic is done. It is the sum of (Lnz \mbox{[}k\mbox{]}) $\ast$ (Lnz \mbox{[}k\mbox{]} + 2) for k = 0 to n-1.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]A and L are n-by-n, where n $>$= 0 \item[{\em Ap}]column pointers of size n+1 \item[{\em Ai}]row indices of size nz=Ap\mbox{[}n\mbox{]} \item[{\em Lp}]column pointers of size n+1 \item[{\em Parent}]elimination tree of size n \item[{\em P}]optional permutation vector of size n \mbox{[}use (int $\ast$) NULL for none\mbox{]} \item[{\em Pinv}]optional inverse permutation \mbox{[}not used if P is NULL\mbox{]} \end{description}
\end{Desc}
\hypertarget{R__ldl_8c_a8}{
\index{R_ldl.c@{R\_\-ldl.c}!R_ldl_valid_matrix@{R\_\-ldl\_\-valid\_\-matrix}}
\index{R_ldl_valid_matrix@{R\_\-ldl\_\-valid\_\-matrix}!R_ldl.c@{R\_\-ldl.c}}
\paragraph[R\_\-ldl\_\-valid\_\-matrix]{\setlength{\rightskip}{0pt plus 5cm}int R\_\-ldl\_\-valid\_\-matrix (int {\em n}, const int {\em Ap}\mbox{[}$\,$\mbox{]}, const int {\em Ai}\mbox{[}$\,$\mbox{]})}\hfill}
\label{R__ldl_8c_a8}


This routine checks to see if a sparse matrix A is valid for input to R\_\-ldl\_\-symbolic and R\_\-ldl\_\-numeric. It returns 1 if the matrix is valid, 0 otherwise. A is in sparse column form. The numerical values in column j are stored in Ax \mbox{[}Ap \mbox{[}j\mbox{]} ... Ap \mbox{[}j+1\mbox{]}-1\mbox{]}, with row indices in Ai \mbox{[}Ap \mbox{[}j\mbox{]} ... Ap \mbox{[}j+1\mbox{]}-1\mbox{]}. The Ax array is not checked.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]A is n by n (n $>$= 0) \item[{\em Ap}]column pointer array of size n+1 \item[{\em Ai}]row index array of size nz=Ap\mbox{[}n\mbox{]}\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]1 if valid sparse matrix, otherwise 0 \end{Desc}
\hypertarget{R__ldl_8c_a7}{
\index{R_ldl.c@{R\_\-ldl.c}!R_ldl_valid_perm@{R\_\-ldl\_\-valid\_\-perm}}
\index{R_ldl_valid_perm@{R\_\-ldl\_\-valid\_\-perm}!R_ldl.c@{R\_\-ldl.c}}
\paragraph[R\_\-ldl\_\-valid\_\-perm]{\setlength{\rightskip}{0pt plus 5cm}int R\_\-ldl\_\-valid\_\-perm (int {\em n}, const int {\em P}\mbox{[}$\,$\mbox{]})}\hfill}
\label{R__ldl_8c_a7}


Check if a permutation vector is valid

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]size of permutation \item[{\em P}]input of size n, a permutation of 0:n-1\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]1 if valid, otherwise 0 \end{Desc}
