\hypertarget{lmer_8c}{
\subsection{lmer.c File Reference}
\label{lmer_8c}\index{lmer.c@{lmer.c}}
}
{\tt \#include \char`\"{}lmer.h\char`\"{}}\par
\subsubsection*{Defines}
\begin{CompactItemize}
\item 
\#define \hyperlink{lmer_8c_a0}{BLK}(i, j)~INTEGER(VECTOR\_\-ELT(VECTOR\_\-ELT(Parent, i), 1))\mbox{[}j\mbox{]}
\item 
\#define \hyperlink{lmer_8c_a1}{PAR}(i, j)~INTEGER(VECTOR\_\-ELT(VECTOR\_\-ELT(Parent, i), 0))\mbox{[}j\mbox{]}
\end{CompactItemize}
\subsubsection*{Functions}
\begin{CompactItemize}
\item 
static R\_\-INLINE int \hyperlink{lmer_8c_a2}{coef\_\-length} (int nf, const int nc\mbox{[}$\,$\mbox{]})
\item 
SEXP \hyperlink{lmer_8c_a3}{lmer\_\-validate} (SEXP x)
\item 
static SEXP \hyperlink{lmer_8c_a4}{lmer\_\-crosstab} (SEXP flist, int nobs, const int nc\mbox{[}$\,$\mbox{]})
\item 
SEXP \hyperlink{lmer_8c_a5}{lmer\_\-update\_\-mm} (SEXP x, SEXP mmats)
\item 
SEXP \hyperlink{lmer_8c_a6}{lmer\_\-create} (SEXP flist, SEXP mmats)
\item 
SEXP \hyperlink{lmer_8c_a7}{lmer\_\-initial} (SEXP x)
\item 
SEXP \hyperlink{lmer_8c_a8}{lmer\_\-inflate} (SEXP x)
\item 
static R\_\-INLINE int $\ast$ \hyperlink{lmer_8c_a9}{block\_\-parent} (int j, int n, int par\mbox{[}$\,$\mbox{]}, SEXP Par\-P)
\item 
SEXP \hyperlink{lmer_8c_a10}{lmer\_\-factor} (SEXP x)
\item 
static void \hyperlink{lmer_8c_a11}{lmer\_\-sm} (enum \hyperlink{Mutils_8h_a57}{CBLAS\_\-SIDE} side, enum \hyperlink{Mutils_8h_a54}{CBLAS\_\-TRANSPOSE} trans, int nf, const int Gp\mbox{[}$\,$\mbox{]}, int n, double alpha, SEXP L, double B\mbox{[}$\,$\mbox{]}, int ldb)
\item 
static int \hyperlink{lmer_8c_a12}{max\_\-nnz} (int j, SEXP Parent)
\item 
static void \hyperlink{lmer_8c_a13}{fill\_\-nnz} (int i, int j, int nf, SEXP Parent, const int nc\mbox{[}$\,$\mbox{]}, int nnz\mbox{[}$\,$\mbox{]}, double $\ast$tmp\mbox{[}$\,$\mbox{]}, int $\ast$ind\mbox{[}$\,$\mbox{]})
\item 
static R\_\-INLINE int \hyperlink{lmer_8c_a14}{fsrch} (int target, const int vals\mbox{[}$\,$\mbox{]}, int nvals)
\item 
SEXP \hyperlink{lmer_8c_a15}{lmer\_\-invert} (SEXP x)
\item 
SEXP \hyperlink{lmer_8c_a16}{lmer\_\-sigma} (SEXP x, SEXP REML)
\item 
SEXP \hyperlink{lmer_8c_a17}{lmer\_\-coef} (SEXP x, SEXP Unc)
\item 
SEXP \hyperlink{lmer_8c_a18}{lmer\_\-coef\-Gets} (SEXP x, SEXP coef, SEXP Unc)
\item 
SEXP \hyperlink{lmer_8c_a19}{lmer\_\-fixef} (SEXP x)
\item 
SEXP \hyperlink{lmer_8c_a20}{lmer\_\-ranef} (SEXP x)
\item 
SEXP \hyperlink{lmer_8c_a21}{lmer\_\-first\-Der} (SEXP x, SEXP val)
\item 
static SEXP \hyperlink{lmer_8c_a22}{EM\_\-grad\_\-array} (int nf, const int nc\mbox{[}$\,$\mbox{]})
\item 
static double $\ast$ \hyperlink{lmer_8c_a23}{EM\_\-grad\_\-lc} (double $\ast$cc, int EM, int REML, int ns\mbox{[}$\,$\mbox{]})
\item 
static void \hyperlink{lmer_8c_a24}{EMsteps\_\-verbose\_\-print} (SEXP x, int iter, int REML, SEXP first\-Der, SEXP val)
\item 
SEXP \hyperlink{lmer_8c_a25}{lmer\_\-ECMEsteps} (SEXP x, SEXP nsteps, SEXP REMLp, SEXP Verbp)
\item 
SEXP \hyperlink{lmer_8c_a26}{lmer\_\-gradient} (SEXP x, SEXP REMLp, SEXP Uncp)
\item 
static SEXP \hyperlink{lmer_8c_a27}{lmer\_\-second\-Der} (SEXP x, SEXP Valp)
\item 
SEXP \hyperlink{lmer_8c_a28}{lmer\_\-variances} (SEXP x)
\item 
SEXP \hyperlink{lmer_8c_a29}{lmer\_\-Crosstab} (SEXP flist)
\end{CompactItemize}


\subsubsection{Define Documentation}
\hypertarget{lmer_8c_a0}{
\index{lmer.c@{lmer.c}!BLK@{BLK}}
\index{BLK@{BLK}!lmer.c@{lmer.c}}
\paragraph[BLK]{\setlength{\rightskip}{0pt plus 5cm}\#define BLK(i, j)~INTEGER(VECTOR\_\-ELT(VECTOR\_\-ELT(Parent, i), 1))\mbox{[}j\mbox{]}}\hfill}
\label{lmer_8c_a0}


\hypertarget{lmer_8c_a1}{
\index{lmer.c@{lmer.c}!PAR@{PAR}}
\index{PAR@{PAR}!lmer.c@{lmer.c}}
\paragraph[PAR]{\setlength{\rightskip}{0pt plus 5cm}\#define PAR(i, j)~INTEGER(VECTOR\_\-ELT(VECTOR\_\-ELT(Parent, i), 0))\mbox{[}j\mbox{]}}\hfill}
\label{lmer_8c_a1}




\subsubsection{Function Documentation}
\hypertarget{lmer_8c_a9}{
\index{lmer.c@{lmer.c}!block_parent@{block\_\-parent}}
\index{block_parent@{block\_\-parent}!lmer.c@{lmer.c}}
\paragraph[block\_\-parent]{\setlength{\rightskip}{0pt plus 5cm}static R\_\-INLINE int$\ast$ block\_\-parent (int {\em j}, int {\em n}, int {\em par}\mbox{[}$\,$\mbox{]}, SEXP {\em Par\-P})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{lmer_8c_a9}


Convert the extended parent pair (Parent, Block) to a parent array for the jth diagonal block of size n.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em j}]index (0-based) of the diagonal outer block \item[{\em n}]number of inner column blocks in the outer block \item[{\em par}]array of length n to be filled with the parent array \item[{\em Par\-P}]pointer to the extended parent structure\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]par \end{Desc}
\hypertarget{lmer_8c_a2}{
\index{lmer.c@{lmer.c}!coef_length@{coef\_\-length}}
\index{coef_length@{coef\_\-length}!lmer.c@{lmer.c}}
\paragraph[coef\_\-length]{\setlength{\rightskip}{0pt plus 5cm}static R\_\-INLINE int coef\_\-length (int {\em nf}, const int {\em nc}\mbox{[}$\,$\mbox{]})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{lmer_8c_a2}


Calculate the length of the parameter vector (historically called \char`\"{}coef\char`\"{} even though these are not coefficients).

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em nf}]number of factors \item[{\em nc}]number of columns in the model matrices for each factor\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]total length of the coefficient vector \end{Desc}
\hypertarget{lmer_8c_a22}{
\index{lmer.c@{lmer.c}!EM_grad_array@{EM\_\-grad\_\-array}}
\index{EM_grad_array@{EM\_\-grad\_\-array}!lmer.c@{lmer.c}}
\paragraph[EM\_\-grad\_\-array]{\setlength{\rightskip}{0pt plus 5cm}static SEXP EM\_\-grad\_\-array (int {\em nf}, const int {\em nc}\mbox{[}$\,$\mbox{]})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{lmer_8c_a22}


Return a length nf list of arrays of dimension (nci, nci, 4). The values of these arrays are assigned in lmer\_\-first\-Der.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em nf}]number of factors \item[{\em nc}]vector of number of columns per factor\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]pointer to a list of REAL arrays \end{Desc}
\hypertarget{lmer_8c_a23}{
\index{lmer.c@{lmer.c}!EM_grad_lc@{EM\_\-grad\_\-lc}}
\index{EM_grad_lc@{EM\_\-grad\_\-lc}!lmer.c@{lmer.c}}
\paragraph[EM\_\-grad\_\-lc]{\setlength{\rightskip}{0pt plus 5cm}static double$\ast$ EM\_\-grad\_\-lc (double $\ast$ {\em cc}, int {\em EM}, int {\em REML}, int {\em ns}\mbox{[}$\,$\mbox{]})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{lmer_8c_a23}


Fill in the 4-dimensional vector of linear combinations of the first\-Der array according to whether ECME steps or the gradient are needed and to whether or not REML is being used.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em cc}]coefficient vector to be filled in \item[{\em EM}]non-zero for ECME steps, zero for gradient \item[{\em REML}]non-zero for REML, zero for ML \item[{\em ns}]ns\mbox{[}0\mbox{]} is p+1, ns\mbox{[}1\mbox{]} is n\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]cc with the coefficients filled in \end{Desc}
\hypertarget{lmer_8c_a24}{
\index{lmer.c@{lmer.c}!EMsteps_verbose_print@{EMsteps\_\-verbose\_\-print}}
\index{EMsteps_verbose_print@{EMsteps\_\-verbose\_\-print}!lmer.c@{lmer.c}}
\paragraph[EMsteps\_\-verbose\_\-print]{\setlength{\rightskip}{0pt plus 5cm}static void EMsteps\_\-verbose\_\-print (SEXP {\em x}, int {\em iter}, int {\em REML}, SEXP {\em first\-Der}, SEXP {\em val})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{lmer_8c_a24}


Print the verbose output in the ECME iterations

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em iter}]iteration number \item[{\em REML}]non-zero for REML, zero for ML \item[{\em first\-Der}]arrays for calculating ECME steps and the first derivative \item[{\em val}]Pointer to a list of arrays to receive the calculated values \end{description}
\end{Desc}
\hypertarget{lmer_8c_a13}{
\index{lmer.c@{lmer.c}!fill_nnz@{fill\_\-nnz}}
\index{fill_nnz@{fill\_\-nnz}!lmer.c@{lmer.c}}
\paragraph[fill\_\-nnz]{\setlength{\rightskip}{0pt plus 5cm}static void fill\_\-nnz (int {\em i}, int {\em j}, int {\em nf}, SEXP {\em Parent}, const int {\em nc}\mbox{[}$\,$\mbox{]}, int {\em nnz}\mbox{[}$\,$\mbox{]}, double $\ast$ {\em tmp}\mbox{[}$\,$\mbox{]}, int $\ast$ {\em ind}\mbox{[}$\,$\mbox{]})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{lmer_8c_a13}


Fill the nnz array with the number of nonzero inner blocks in each outer block of the jth inner column block of the ith outer block of L$^\wedge$\{-1\}. Also allocate the tmp and ind arrays and fill the ind array.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em i}]outer block index \item[{\em j}]inner block index within the ith outer block \item[{\em nf}]number of factors \item[{\em Parent}]pointer to the extended parent pairs \item[{\em nc}]\item[{\em nnz}]array of length nf \item[{\em tmp}]array of length nf of pointers to doubles \item[{\em ind}]array of length nf of pointers to ints \end{description}
\end{Desc}
\hypertarget{lmer_8c_a14}{
\index{lmer.c@{lmer.c}!fsrch@{fsrch}}
\index{fsrch@{fsrch}!lmer.c@{lmer.c}}
\paragraph[fsrch]{\setlength{\rightskip}{0pt plus 5cm}static R\_\-INLINE int fsrch (int {\em target}, const int {\em vals}\mbox{[}$\,$\mbox{]}, int {\em nvals})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{lmer_8c_a14}


\hypertarget{lmer_8c_a17}{
\index{lmer.c@{lmer.c}!lmer_coef@{lmer\_\-coef}}
\index{lmer_coef@{lmer\_\-coef}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-coef]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-coef (SEXP {\em x}, SEXP {\em Unc})}\hfill}
\label{lmer_8c_a17}


Extract the upper triangles of the Omega matrices. These aren't \char`\"{}coefficients\char`\"{} but the extractor is called coef for historical reasons. Within each group these values are in the order of the diagonal entries first then the strict upper triangle in row order.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an lme object \item[{\em Unc}]pointer to a logical scalar indicating if the parameters are in the unconstrained form.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]numeric vector of the values in the upper triangles of the Omega matrices \end{Desc}
\hypertarget{lmer_8c_a18}{
\index{lmer.c@{lmer.c}!lmer_coefGets@{lmer\_\-coefGets}}
\index{lmer_coefGets@{lmer\_\-coefGets}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-coefGets]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-coef\-Gets (SEXP {\em x}, SEXP {\em coef}, SEXP {\em Unc})}\hfill}
\label{lmer_8c_a18}


Assign the upper triangles of the Omega matrices. (Called coef for historical reasons.)

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an lme object \item[{\em coef}]pointer to an numeric vector of appropriate length \item[{\em Unc}]pointer to a logical scalar indicating if the parameters are in the unconstrained form.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]R\_\-Nil\-Value \end{Desc}
\hypertarget{lmer_8c_a6}{
\index{lmer.c@{lmer.c}!lmer_create@{lmer\_\-create}}
\index{lmer_create@{lmer\_\-create}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-create]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-create (SEXP {\em flist}, SEXP {\em mmats})}\hfill}
\label{lmer_8c_a6}


Create an lmer object from a list of grouping factors and a list of model matrices. There is one more model matrix than grouping factor. The last model matrix is the fixed effects and the response.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em flist}]pointer to a list of grouping factors \item[{\em mmats}]pointer to a list of model matrices\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]pointer to an lmer object \end{Desc}
\hypertarget{lmer_8c_a29}{
\index{lmer.c@{lmer.c}!lmer_Crosstab@{lmer\_\-Crosstab}}
\index{lmer_Crosstab@{lmer\_\-Crosstab}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-Crosstab]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-Crosstab (SEXP {\em flist})}\hfill}
\label{lmer_8c_a29}


\hypertarget{lmer_8c_a4}{
\index{lmer.c@{lmer.c}!lmer_crosstab@{lmer\_\-crosstab}}
\index{lmer_crosstab@{lmer\_\-crosstab}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-crosstab]{\setlength{\rightskip}{0pt plus 5cm}static SEXP lmer\_\-crosstab (SEXP {\em flist}, int {\em nobs}, const int {\em nc}\mbox{[}$\,$\mbox{]})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{lmer_8c_a4}


Create the pairwise crosstabulation of the elements of flist.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em flist}]pointer to the factor list. \item[{\em nobs}]number of observations. \item[{\em nc}]number of columns in the model matrices.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]the pairwise crosstabulation in the form of the Zt\-Z array. \end{Desc}
\hypertarget{lmer_8c_a25}{
\index{lmer.c@{lmer.c}!lmer_ECMEsteps@{lmer\_\-ECMEsteps}}
\index{lmer_ECMEsteps@{lmer\_\-ECMEsteps}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-ECMEsteps]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-ECMEsteps (SEXP {\em x}, SEXP {\em nsteps}, SEXP {\em REMLp}, SEXP {\em Verbp})}\hfill}
\label{lmer_8c_a25}


Perform ECME steps for the REML or ML criterion.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em nsteps}]pointer to an integer scalar - the number of ECME steps to perform \item[{\em REMLp}]pointer to a logical scalar indicating if REML is to be used \item[{\em Verbp}]pointer to a logical scalar indicating verbose output\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]R\_\-Nil\-Value if verb == FALSE, otherwise a list of iteration numbers, deviances, parameters, and gradients. \end{Desc}
\hypertarget{lmer_8c_a10}{
\index{lmer.c@{lmer.c}!lmer_factor@{lmer\_\-factor}}
\index{lmer_factor@{lmer\_\-factor}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-factor]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-factor (SEXP {\em x})}\hfill}
\label{lmer_8c_a10}


If status\mbox{[}\mbox{[}\char`\"{}factored\char`\"{}\mbox{]}\mbox{]} is FALSE, create and factor Z'Z+Omega. Also create RZX and RXX, the deviance components, and the value of the deviance for both ML and REML.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an lmer object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]NULL \end{Desc}
\hypertarget{lmer_8c_a21}{
\index{lmer.c@{lmer.c}!lmer_firstDer@{lmer\_\-firstDer}}
\index{lmer_firstDer@{lmer\_\-firstDer}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-firstDer]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-first\-Der (SEXP {\em x}, SEXP {\em val})}\hfill}
\label{lmer_8c_a21}


Fill in four symmetric matrices for each level, providing the information to generate the gradient or the ECME step. The four matrices are 1) -m\_\-i$^\wedge$\{-1\} 2)  3) \mbox{[}\{\}(+)\mbox{]} 4) The term added to 3) to get \mbox{[}\{\}\mbox{]}

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an lme object \item[{\em val}]pointer to a list of matrices of the correct sizes\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]val \end{Desc}
\hypertarget{lmer_8c_a19}{
\index{lmer.c@{lmer.c}!lmer_fixef@{lmer\_\-fixef}}
\index{lmer_fixef@{lmer\_\-fixef}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-fixef]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-fixef (SEXP {\em x})}\hfill}
\label{lmer_8c_a19}


Extract the conditional estimates of the fixed effects

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]Pointer to an lme object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]a numeric vector containing the conditional estimates of the fixed effects \end{Desc}
\hypertarget{lmer_8c_a26}{
\index{lmer.c@{lmer.c}!lmer_gradient@{lmer\_\-gradient}}
\index{lmer_gradient@{lmer\_\-gradient}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-gradient]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-gradient (SEXP {\em x}, SEXP {\em REMLp}, SEXP {\em Uncp})}\hfill}
\label{lmer_8c_a26}


\hypertarget{lmer_8c_a8}{
\index{lmer.c@{lmer.c}!lmer_inflate@{lmer\_\-inflate}}
\index{lmer_inflate@{lmer\_\-inflate}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-inflate]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-inflate (SEXP {\em x})}\hfill}
\label{lmer_8c_a8}


Copy Zt\-Z to ZZp\-O and L. Inflate diagonal blocks of ZZp\-O by Omega. Update dev\-Comp\mbox{[}1\mbox{]}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an lmer object \end{description}
\end{Desc}
\hypertarget{lmer_8c_a7}{
\index{lmer.c@{lmer.c}!lmer_initial@{lmer\_\-initial}}
\index{lmer_initial@{lmer\_\-initial}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-initial]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-initial (SEXP {\em x})}\hfill}
\label{lmer_8c_a7}


Create and insert initial values for Omega.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an lmer object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]NULL \end{Desc}
\hypertarget{lmer_8c_a15}{
\index{lmer.c@{lmer.c}!lmer_invert@{lmer\_\-invert}}
\index{lmer_invert@{lmer\_\-invert}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-invert]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-invert (SEXP {\em x})}\hfill}
\label{lmer_8c_a15}


If necessary, factor Z'Z+Omega, Zt\-X, and Xt\-X then, if necessary, replace the RZX and RXX slots by the corresponding parts of the inverse of the Cholesky factor. Replace the elements of the D slot by the blockwise inverses and evaluate b\-Var.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an lmer object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]NULL (x is updated in place) \end{Desc}
\hypertarget{lmer_8c_a20}{
\index{lmer.c@{lmer.c}!lmer_ranef@{lmer\_\-ranef}}
\index{lmer_ranef@{lmer\_\-ranef}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-ranef]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-ranef (SEXP {\em x})}\hfill}
\label{lmer_8c_a20}


Extract the conditional modes of the random effects.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]Pointer to an lme object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]a vector containing the conditional modes of the random effects \end{Desc}
\hypertarget{lmer_8c_a27}{
\index{lmer.c@{lmer.c}!lmer_secondDer@{lmer\_\-secondDer}}
\index{lmer_secondDer@{lmer\_\-secondDer}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-secondDer]{\setlength{\rightskip}{0pt plus 5cm}static SEXP lmer\_\-second\-Der (SEXP {\em x}, SEXP {\em Valp})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{lmer_8c_a27}


Fill in five symmetric matrices, providing the information to generate the Hessian.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an lme object \item[{\em Valp}]ignored at present\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Valp an array consisting of five symmetric faces \end{Desc}
\hypertarget{lmer_8c_a16}{
\index{lmer.c@{lmer.c}!lmer_sigma@{lmer\_\-sigma}}
\index{lmer_sigma@{lmer\_\-sigma}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-sigma]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-sigma (SEXP {\em x}, SEXP {\em REML})}\hfill}
\label{lmer_8c_a16}


Extract the ML or REML conditional estimate of sigma

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an lme object \item[{\em REML}]logical scalar - TRUE if REML estimates are requested\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]pointer to a numeric scalar \end{Desc}
\hypertarget{lmer_8c_a11}{
\index{lmer.c@{lmer.c}!lmer_sm@{lmer\_\-sm}}
\index{lmer_sm@{lmer\_\-sm}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-sm]{\setlength{\rightskip}{0pt plus 5cm}static void lmer\_\-sm (enum \hyperlink{Mutils_8h_a57}{CBLAS\_\-SIDE} {\em side}, enum \hyperlink{Mutils_8h_a54}{CBLAS\_\-TRANSPOSE} {\em trans}, int {\em nf}, const int {\em Gp}\mbox{[}$\,$\mbox{]}, int {\em n}, double {\em alpha}, SEXP {\em L}, double {\em B}\mbox{[}$\,$\mbox{]}, int {\em ldb})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{lmer_8c_a11}


Solve one of the matrix equations op(L)$\ast$X=alpha$\ast$B or X$\ast$op(L)=alpha$\ast$B where L is a sparse, blocked, unit lower triangular matrix.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em side}]LFT or RGT for left or right \item[{\em trans}]TRN or NTR for transpose or no transpose \item[{\em nf}]number of grouping factors \item[{\em Gp}]group pointers for the rows \item[{\em n}]number of columns \item[{\em alpha}]multiplier \item[{\em L}]pointer to the L cscb object \item[{\em B}]pointer to the matrix of right-hand sides \item[{\em ldb}]leading dimension of array B as declared in the caller \end{description}
\end{Desc}
\hypertarget{lmer_8c_a5}{
\index{lmer.c@{lmer.c}!lmer_update_mm@{lmer\_\-update\_\-mm}}
\index{lmer_update_mm@{lmer\_\-update\_\-mm}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-update\_\-mm]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-update\_\-mm (SEXP {\em x}, SEXP {\em mmats})}\hfill}
\label{lmer_8c_a5}


Update the arrays Zt\-Z, Zt\-X, and Xt\-X in an lme object according to a list of model matrices.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an lmer object \item[{\em mmats}]pointer to a list of model matrices\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]NULL \end{Desc}
\hypertarget{lmer_8c_a3}{
\index{lmer.c@{lmer.c}!lmer_validate@{lmer\_\-validate}}
\index{lmer_validate@{lmer\_\-validate}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-validate]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-validate (SEXP {\em x})}\hfill}
\label{lmer_8c_a3}


Check validity of an lmer object.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]Pointer to an lmer object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]TRUE if the object is a valid lmer object, else a string describing the nature of the violation. \end{Desc}
\hypertarget{lmer_8c_a28}{
\index{lmer.c@{lmer.c}!lmer_variances@{lmer\_\-variances}}
\index{lmer_variances@{lmer\_\-variances}!lmer.c@{lmer.c}}
\paragraph[lmer\_\-variances]{\setlength{\rightskip}{0pt plus 5cm}SEXP lmer\_\-variances (SEXP {\em x})}\hfill}
\label{lmer_8c_a28}


Return the unscaled variances

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an lmer object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]a list similar to the Omega list with the unscaled variances \end{Desc}
\hypertarget{lmer_8c_a12}{
\index{lmer.c@{lmer.c}!max_nnz@{max\_\-nnz}}
\index{max_nnz@{max\_\-nnz}!lmer.c@{lmer.c}}
\paragraph[max\_\-nnz]{\setlength{\rightskip}{0pt plus 5cm}static int max\_\-nnz (int {\em j}, SEXP {\em Parent})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{lmer_8c_a12}


