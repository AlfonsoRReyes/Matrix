\hypertarget{ssclme_8c}{
\subsection{ssclme.c File Reference}
\label{ssclme_8c}\index{ssclme.c@{ssclme.c}}
}
{\tt \#include \char`\"{}ssclme.h\char`\"{}}\par
\subsubsection*{Defines}
\begin{CompactItemize}
\item 
\#define \hyperlink{ssclme_8c_a0}{slot\_\-dup}(dest, src, sym)~SET\_\-SLOT(dest, sym, duplicate(GET\_\-SLOT(src, sym)))
\end{CompactItemize}
\subsubsection*{Functions}
\begin{CompactItemize}
\item 
static void \hyperlink{ssclme_8c_a1}{ssclme\_\-copy\_\-ctab} (int nf, const int nc\mbox{[}$\,$\mbox{]}, SEXP ctab, SEXP ssc)
\item 
static void \hyperlink{ssclme_8c_a2}{ssclme\_\-calc\_\-maxod} (int n, int Parent\mbox{[}$\,$\mbox{]})
\item 
SEXP \hyperlink{ssclme_8c_a3}{ssclme\_\-create} (SEXP facs, SEXP ncv)
\item 
static void \hyperlink{ssclme_8c_a4}{b\-Vj\_\-to\_\-A} (int ncj, int Gpj, int Gpjp, const double b\-Vj\mbox{[}$\,$\mbox{]}, const int Ap\mbox{[}$\,$\mbox{]}, const int Ai\mbox{[}$\,$\mbox{]}, double Ax\mbox{[}$\,$\mbox{]})
\item 
SEXP \hyperlink{ssclme_8c_a5}{ssclme\_\-transfer\_\-dimnames} (SEXP x, SEXP facs, SEXP mmats)
\item 
SEXP \hyperlink{ssclme_8c_a6}{ssclme\_\-update\_\-mm} (SEXP x, SEXP facs, SEXP mmats)
\item 
SEXP \hyperlink{ssclme_8c_a7}{ssclme\_\-inflate\_\-and\_\-factor} (SEXP x)
\item 
SEXP \hyperlink{ssclme_8c_a8}{ssclme\_\-factor} (SEXP x)
\item 
static int \hyperlink{ssclme_8c_a9}{ldl\_\-update\_\-ind} (int probe, int start, const int ind\mbox{[}$\,$\mbox{]})
\item 
static void \hyperlink{ssclme_8c_a10}{ldl\_\-inverse} (SEXP x)
\item 
SEXP \hyperlink{ssclme_8c_a11}{ssclme\_\-invert} (SEXP x)
\item 
SEXP \hyperlink{ssclme_8c_a12}{ssclme\_\-initial} (SEXP x)
\item 
SEXP \hyperlink{ssclme_8c_a13}{ssclme\_\-fixef} (SEXP x)
\item 
SEXP \hyperlink{ssclme_8c_a14}{ssclme\_\-ranef} (SEXP x)
\item 
SEXP \hyperlink{ssclme_8c_a15}{ssclme\_\-sigma} (SEXP x, SEXP REML)
\item 
static int \hyperlink{ssclme_8c_a16}{coef\_\-length} (int nf, const int nc\mbox{[}$\,$\mbox{]})
\item 
SEXP \hyperlink{ssclme_8c_a17}{ssclme\_\-coef} (SEXP x, SEXP Unconstr)
\item 
SEXP \hyperlink{ssclme_8c_a18}{ssclme\_\-coef\-Unc} (SEXP x)
\item 
SEXP \hyperlink{ssclme_8c_a19}{ssclme\_\-coef\-Gets\-Unc} (SEXP x, SEXP coef)
\item 
SEXP \hyperlink{ssclme_8c_a20}{ssclme\_\-coef\-Gets} (SEXP x, SEXP coef, SEXP Unc)
\item 
static void \hyperlink{ssclme_8c_a21}{common\_\-ECME\_\-gradient} (SEXP x, int REML, SEXP val)
\item 
static void \hyperlink{ssclme_8c_a22}{EMsteps\_\-verbose\_\-print} (SEXP x, int iter, int REML)
\item 
SEXP \hyperlink{ssclme_8c_a23}{ssclme\_\-EMsteps} (SEXP x, SEXP nsteps, SEXP REMLp, SEXP verb)
\item 
static void \hyperlink{ssclme_8c_a24}{indicator\_\-gradient} (SEXP x, int REML, SEXP val)
\item 
static void \hyperlink{ssclme_8c_a25}{unconstrained\_\-gradient} (SEXP grad, SEXP Omega)
\item 
static void \hyperlink{ssclme_8c_a26}{upper\-Tri\-List\_\-to\_\-vector} (SEXP m\-List, int $\ast$nc, SEXP cvec)
\item 
SEXP \hyperlink{ssclme_8c_a27}{ssclme\_\-grad} (SEXP x, SEXP REMLp, SEXP Unc, SEXP One\-Vector)
\item 
SEXP \hyperlink{ssclme_8c_a28}{ssclme\_\-gradient} (SEXP x, SEXP REMLp, SEXP Uncp)
\item 
SEXP \hyperlink{ssclme_8c_a29}{ssclme\_\-Hessian} (SEXP x, SEXP REMLp, SEXP Uncp)
\item 
SEXP \hyperlink{ssclme_8c_a30}{ssclme\_\-fitted} (SEXP x, SEXP facs, SEXP mmats, SEXP use\-Rf)
\item 
SEXP \hyperlink{ssclme_8c_a31}{ssclme\_\-variances} (SEXP x)
\item 
SEXP \hyperlink{ssclme_8c_a32}{ssclme\_\-collapse} (SEXP x)
\item 
SEXP \hyperlink{ssclme_8c_a33}{ssclme\_\-to\_\-lme} (SEXP call, SEXP facs, SEXP x, SEXP model, SEXP REML, SEXP rep, SEXP fitted, SEXP residuals, SEXP terms, SEXP assign)
\end{CompactItemize}


\subsubsection{Define Documentation}
\hypertarget{ssclme_8c_a0}{
\index{ssclme.c@{ssclme.c}!slot_dup@{slot\_\-dup}}
\index{slot_dup@{slot\_\-dup}!ssclme.c@{ssclme.c}}
\paragraph[slot\_\-dup]{\setlength{\rightskip}{0pt plus 5cm}\#define slot\_\-dup(dest, src, sym)~SET\_\-SLOT(dest, sym, duplicate(GET\_\-SLOT(src, sym)))}\hfill}
\label{ssclme_8c_a0}




\subsubsection{Function Documentation}
\hypertarget{ssclme_8c_a4}{
\index{ssclme.c@{ssclme.c}!bVj_to_A@{bVj\_\-to\_\-A}}
\index{bVj_to_A@{bVj\_\-to\_\-A}!ssclme.c@{ssclme.c}}
\paragraph[bVj\_\-to\_\-A]{\setlength{\rightskip}{0pt plus 5cm}static void b\-Vj\_\-to\_\-A (int {\em ncj}, int {\em Gpj}, int {\em Gpjp}, const double {\em b\-Vj}\mbox{[}$\,$\mbox{]}, const int {\em Ap}\mbox{[}$\,$\mbox{]}, const int {\em Ai}\mbox{[}$\,$\mbox{]}, double {\em Ax}\mbox{[}$\,$\mbox{]})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{ssclme_8c_a4}


Copy information on Z'Z accumulated in the b\-Var array to Z'Z

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em ncj}]number of columns in this block \item[{\em Gpj}]initial column for this group \item[{\em Gpjp}]initial column for the next group \item[{\em b\-Vj}]pointer to the ncj x ncj x mj array to be filled \item[{\em Ap}]column pointer array for Z'Z \item[{\em Ai}]row indices for Z'Z \item[{\em Ax}]elements of Z'Z \end{description}
\end{Desc}
\hypertarget{ssclme_8c_a16}{
\index{ssclme.c@{ssclme.c}!coef_length@{coef\_\-length}}
\index{coef_length@{coef\_\-length}!ssclme.c@{ssclme.c}}
\paragraph[coef\_\-length]{\setlength{\rightskip}{0pt plus 5cm}static int coef\_\-length (int {\em nf}, const int {\em nc}\mbox{[}$\,$\mbox{]})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{ssclme_8c_a16}


Calculate the length of the parameter vector, which is called coef for historical reasons.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em nf}]number of factors \item[{\em nc}]number of columns in the model matrices for each factor\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]total length of the coefficient vector \end{Desc}
\hypertarget{ssclme_8c_a21}{
\index{ssclme.c@{ssclme.c}!common_ECME_gradient@{common\_\-ECME\_\-gradient}}
\index{common_ECME_gradient@{common\_\-ECME\_\-gradient}!ssclme.c@{ssclme.c}}
\paragraph[common\_\-ECME\_\-gradient]{\setlength{\rightskip}{0pt plus 5cm}static void common\_\-ECME\_\-gradient (SEXP {\em x}, int {\em REML}, SEXP {\em val})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{ssclme_8c_a21}


Returns the inverse of the updated Omega matrices for an ECME iteration. These matrices are also used in the gradient calculation.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em REML}]indicator of REML being used \item[{\em val}]pointer to a list of symmetric q\_\-i by q\_\-i matrices \end{description}
\end{Desc}
\hypertarget{ssclme_8c_a22}{
\index{ssclme.c@{ssclme.c}!EMsteps_verbose_print@{EMsteps\_\-verbose\_\-print}}
\index{EMsteps_verbose_print@{EMsteps\_\-verbose\_\-print}!ssclme.c@{ssclme.c}}
\paragraph[EMsteps\_\-verbose\_\-print]{\setlength{\rightskip}{0pt plus 5cm}static void EMsteps\_\-verbose\_\-print (SEXP {\em x}, int {\em iter}, int {\em REML})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{ssclme_8c_a22}


Print the verbose output in the ECME iterations

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em iter}]iteration number \item[{\em REML}]indicator of whether REML is being used \end{description}
\end{Desc}
\hypertarget{ssclme_8c_a24}{
\index{ssclme.c@{ssclme.c}!indicator_gradient@{indicator\_\-gradient}}
\index{indicator_gradient@{indicator\_\-gradient}!ssclme.c@{ssclme.c}}
\paragraph[indicator\_\-gradient]{\setlength{\rightskip}{0pt plus 5cm}static void indicator\_\-gradient (SEXP {\em x}, int {\em REML}, SEXP {\em val})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{ssclme_8c_a24}


Evaluate the gradient with respect to the indicators of the positions in the Omega matrices.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]Pointer to an ssclme object \item[{\em REML}]indicator of whether REML is to be used \item[{\em val}]Pointer to an object of the same structure as Omega \end{description}
\end{Desc}
\hypertarget{ssclme_8c_a10}{
\index{ssclme.c@{ssclme.c}!ldl_inverse@{ldl\_\-inverse}}
\index{ldl_inverse@{ldl\_\-inverse}!ssclme.c@{ssclme.c}}
\paragraph[ldl\_\-inverse]{\setlength{\rightskip}{0pt plus 5cm}static void ldl\_\-inverse (SEXP {\em x})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{ssclme_8c_a10}


Update the diagonal blocks of the inverse of LDL' (=Z'Z+W). The lower Cholesky factors of the updated blocks are stored in the b\-Var slot.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]R\_\-Nil\-Value (x is updated in place) \end{Desc}
\hypertarget{ssclme_8c_a9}{
\index{ssclme.c@{ssclme.c}!ldl_update_ind@{ldl\_\-update\_\-ind}}
\index{ldl_update_ind@{ldl\_\-update\_\-ind}!ssclme.c@{ssclme.c}}
\paragraph[ldl\_\-update\_\-ind]{\setlength{\rightskip}{0pt plus 5cm}static int ldl\_\-update\_\-ind (int {\em probe}, int {\em start}, const int {\em ind}\mbox{[}$\,$\mbox{]})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{ssclme_8c_a9}


Return the position of probe in the sorted index vector ind. It is known that the position is greater than or equal to start so a linear search from start is used.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em probe}]value to be matched \item[{\em start}]index at which to start \item[{\em ind}]vector of indices\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]index of the entry matching probe \end{Desc}
\hypertarget{ssclme_8c_a2}{
\index{ssclme.c@{ssclme.c}!ssclme_calc_maxod@{ssclme\_\-calc\_\-maxod}}
\index{ssclme_calc_maxod@{ssclme\_\-calc\_\-maxod}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-calc\_\-maxod]{\setlength{\rightskip}{0pt plus 5cm}static void ssclme\_\-calc\_\-maxod (int {\em n}, int {\em Parent}\mbox{[}$\,$\mbox{]})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{ssclme_8c_a2}


Calculate and store the maximum number of off-diagonal elements in the inverse of L, based on the elimination tree. The maximum is itself stored in the Parent array. (FIXME: come up with a better design.)

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]number of columns in the matrix \item[{\em Parent}]elimination tree for the matrix \end{description}
\end{Desc}
\hypertarget{ssclme_8c_a17}{
\index{ssclme.c@{ssclme.c}!ssclme_coef@{ssclme\_\-coef}}
\index{ssclme_coef@{ssclme\_\-coef}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-coef]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-coef (SEXP {\em x}, SEXP {\em Unconstr})}\hfill}
\label{ssclme_8c_a17}


Extract the upper triangles of the Omega matrices. These aren't \char`\"{}coefficients\char`\"{} but the extractor is called coef for historical reasons. Within each group these values are in the order of the diagonal entries first then the strict upper triangle in row order.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em Unconstr}]pointer to a logical object indicating if the unconstrained parameterization should be used.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]numeric vector of the values in the upper triangles of the Omega matrices \end{Desc}
\hypertarget{ssclme_8c_a20}{
\index{ssclme.c@{ssclme.c}!ssclme_coefGets@{ssclme\_\-coefGets}}
\index{ssclme_coefGets@{ssclme\_\-coefGets}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-coefGets]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-coef\-Gets (SEXP {\em x}, SEXP {\em coef}, SEXP {\em Unc})}\hfill}
\label{ssclme_8c_a20}


Assign the upper triangles of the Omega matrices. (Called coef for historical reasons.)

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em coef}]pointer to an numeric vector of appropriate length \item[{\em Unc}]pointer to a logical object indicating if the unconstrained parameterization should be used.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]R\_\-Nil\-Value \end{Desc}
\hypertarget{ssclme_8c_a19}{
\index{ssclme.c@{ssclme.c}!ssclme_coefGetsUnc@{ssclme\_\-coefGetsUnc}}
\index{ssclme_coefGetsUnc@{ssclme\_\-coefGetsUnc}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-coefGetsUnc]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-coef\-Gets\-Unc (SEXP {\em x}, SEXP {\em coef})}\hfill}
\label{ssclme_8c_a19}


Assign the Omega matrices from the unconstrained parameterization.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em coef}]pointer to an numeric vector of appropriate length\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]R\_\-Nil\-Value \end{Desc}
\hypertarget{ssclme_8c_a18}{
\index{ssclme.c@{ssclme.c}!ssclme_coefUnc@{ssclme\_\-coefUnc}}
\index{ssclme_coefUnc@{ssclme\_\-coefUnc}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-coefUnc]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-coef\-Unc (SEXP {\em x})}\hfill}
\label{ssclme_8c_a18}


Extract the unconstrained parameters that determine the Omega matrices. (Called coef for historical reasons.) The unconstrained parameters are derived from the LDL' decomposition of Omega\_\-i. The first nc\mbox{[}i\mbox{]} entries in each group are the diagonals of log(D) followed by the strict lower triangle of L in column order.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]numeric vector of unconstrained parameters that determine the Omega matrices \end{Desc}
\hypertarget{ssclme_8c_a32}{
\index{ssclme.c@{ssclme.c}!ssclme_collapse@{ssclme\_\-collapse}}
\index{ssclme_collapse@{ssclme\_\-collapse}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-collapse]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-collapse (SEXP {\em x})}\hfill}
\label{ssclme_8c_a32}


Copy an ssclme object collapsing the fixed effects slots to the response only.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]a duplicate of x with the fixed effects slots collapsed to the response only \end{Desc}
\hypertarget{ssclme_8c_a1}{
\index{ssclme.c@{ssclme.c}!ssclme_copy_ctab@{ssclme\_\-copy\_\-ctab}}
\index{ssclme_copy_ctab@{ssclme\_\-copy\_\-ctab}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-copy\_\-ctab]{\setlength{\rightskip}{0pt plus 5cm}static void ssclme\_\-copy\_\-ctab (int {\em nf}, const int {\em nc}\mbox{[}$\,$\mbox{]}, SEXP {\em ctab}, SEXP {\em ssc})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{ssclme_8c_a1}


Using the ssc\-Crosstab object from the grouping factors, generate the slots in an ssclme object related to the symmetric sparse matrix representation of Z'Z. If the model matrices for the grouping factors have only one column each then the structure can be copied, otherwise it must be generated from the ssc\-Crosstab and the number of columns per grouping factor.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em nf}]number of factors \item[{\em nc}]vector of length nf+2 with number of columns in model matrices \item[{\em ctab}]pointer to the ssc\-Crosstab object \item[{\em ssc}]pointer to an ssclme object to be filled out \end{description}
\end{Desc}
\hypertarget{ssclme_8c_a3}{
\index{ssclme.c@{ssclme.c}!ssclme_create@{ssclme\_\-create}}
\index{ssclme_create@{ssclme\_\-create}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-create]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-create (SEXP {\em facs}, SEXP {\em ncv})}\hfill}
\label{ssclme_8c_a3}


Create an ssclme object from a list of grouping factors, sorted in order of non-increasing numbers of levels, and an integer vector of the number of columns in the model matrices. There is one more element in ncv than in facs. The last element is the number of columns in the model matrix for the fixed effects plus the response. (i.e. p+1)

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em facs}]pointer to a list of grouping factors \item[{\em ncv}]pointer to an integer vector of number of columns per model matrix\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]pointer to an ssclme object \end{Desc}
\hypertarget{ssclme_8c_a23}{
\index{ssclme.c@{ssclme.c}!ssclme_EMsteps@{ssclme\_\-EMsteps}}
\index{ssclme_EMsteps@{ssclme\_\-EMsteps}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-EMsteps]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-EMsteps (SEXP {\em x}, SEXP {\em nsteps}, SEXP {\em REMLp}, SEXP {\em verb})}\hfill}
\label{ssclme_8c_a23}


Perform ECME steps for the REML or ML criterion.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em nsteps}]pointer to an integer scalar - the number of ECME steps to perform \item[{\em REMLp}]pointer to a logical scalar indicating if REML is to be used \item[{\em verb}]pointer to a logical scalar indicating verbose mode\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]NULL \end{Desc}
\hypertarget{ssclme_8c_a8}{
\index{ssclme.c@{ssclme.c}!ssclme_factor@{ssclme\_\-factor}}
\index{ssclme_factor@{ssclme\_\-factor}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-factor]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-factor (SEXP {\em x})}\hfill}
\label{ssclme_8c_a8}


If status\mbox{[}\mbox{[}\char`\"{}factored\char`\"{}\mbox{]}\mbox{]} is FALSE, create and factor Z'Z+Omega, then create RZX and RXX, the deviance components, and the value of the deviance for both ML and REML.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]NULL \end{Desc}
\hypertarget{ssclme_8c_a30}{
\index{ssclme.c@{ssclme.c}!ssclme_fitted@{ssclme\_\-fitted}}
\index{ssclme_fitted@{ssclme\_\-fitted}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-fitted]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-fitted (SEXP {\em x}, SEXP {\em facs}, SEXP {\em mmats}, SEXP {\em use\-Rf})}\hfill}
\label{ssclme_8c_a30}


Calculate and return the fitted values.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em facs}]list of grouping factors \item[{\em mmats}]list of model matrices \item[{\em use\-Rf}]pointer to a logical scalar indicating if the random effects should be used\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]pointer to a numeric array of fitted values \end{Desc}
\hypertarget{ssclme_8c_a13}{
\index{ssclme.c@{ssclme.c}!ssclme_fixef@{ssclme\_\-fixef}}
\index{ssclme_fixef@{ssclme\_\-fixef}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-fixef]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-fixef (SEXP {\em x})}\hfill}
\label{ssclme_8c_a13}


Extract the conditional estimates of the fixed effects

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]Pointer to an ssclme object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]a numeric vector containing the conditional estimates of the fixed effects \end{Desc}
\hypertarget{ssclme_8c_a27}{
\index{ssclme.c@{ssclme.c}!ssclme_grad@{ssclme\_\-grad}}
\index{ssclme_grad@{ssclme\_\-grad}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-grad]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-grad (SEXP {\em x}, SEXP {\em REMLp}, SEXP {\em Unc}, SEXP {\em One\-Vector})}\hfill}
\label{ssclme_8c_a27}


Return the gradient of the ML or REML deviance.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em REMLp}]pointer to a logical scalar indicating if REML is to be used \item[{\em Unc}]pointer to a logical scalar indicating if the unconstrained parameterization is to be used \item[{\em One\-Vector}]pointer to a logical scalar indicating if result should be a single vector.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]pointer to the gradient as a list of matrices or as a vector. \end{Desc}
\hypertarget{ssclme_8c_a28}{
\index{ssclme.c@{ssclme.c}!ssclme_gradient@{ssclme\_\-gradient}}
\index{ssclme_gradient@{ssclme\_\-gradient}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-gradient]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-gradient (SEXP {\em x}, SEXP {\em REMLp}, SEXP {\em Uncp})}\hfill}
\label{ssclme_8c_a28}


\hypertarget{ssclme_8c_a29}{
\index{ssclme.c@{ssclme.c}!ssclme_Hessian@{ssclme\_\-Hessian}}
\index{ssclme_Hessian@{ssclme\_\-Hessian}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-Hessian]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-Hessian (SEXP {\em x}, SEXP {\em REMLp}, SEXP {\em Uncp})}\hfill}
\label{ssclme_8c_a29}


Return the Hessian of the ML or REML deviance. This is a placeholder until I work out the evaluation of the analytic Hessian, which probably will involve several helper functions.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em REMLp}]pointer to a logical scalar indicating if REML is to be used \item[{\em Uncp}]pointer to a logical scalar indicating if the unconstrained parameterization is to be used\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]pointer to an approximate Hessian matrix \end{Desc}
\hypertarget{ssclme_8c_a7}{
\index{ssclme.c@{ssclme.c}!ssclme_inflate_and_factor@{ssclme\_\-inflate\_\-and\_\-factor}}
\index{ssclme_inflate_and_factor@{ssclme\_\-inflate\_\-and\_\-factor}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-inflate\_\-and\_\-factor]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-inflate\_\-and\_\-factor (SEXP {\em x})}\hfill}
\label{ssclme_8c_a7}


Inflate Z'Z according to Omega and create the factorization LDL'

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]NULL \end{Desc}
\hypertarget{ssclme_8c_a12}{
\index{ssclme.c@{ssclme.c}!ssclme_initial@{ssclme\_\-initial}}
\index{ssclme_initial@{ssclme\_\-initial}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-initial]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-initial (SEXP {\em x})}\hfill}
\label{ssclme_8c_a12}


Create and insert initial values for Omega\_\-i.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]NULL \end{Desc}
\hypertarget{ssclme_8c_a11}{
\index{ssclme.c@{ssclme.c}!ssclme_invert@{ssclme\_\-invert}}
\index{ssclme_invert@{ssclme\_\-invert}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-invert]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-invert (SEXP {\em x})}\hfill}
\label{ssclme_8c_a11}


If necessary, factor Z'Z+Omega, Zt\-X, and Xt\-X then, if necessary, form RZX, RXX, and b\-Var for the inverse of the Cholesky factor.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]NULL (x is updated in place) \end{Desc}
\hypertarget{ssclme_8c_a14}{
\index{ssclme.c@{ssclme.c}!ssclme_ranef@{ssclme\_\-ranef}}
\index{ssclme_ranef@{ssclme\_\-ranef}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-ranef]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-ranef (SEXP {\em x})}\hfill}
\label{ssclme_8c_a14}


Extract the conditional modes of the random effects.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]Pointer to an ssclme object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]a list containing the conditional modes of the random effects \end{Desc}
\hypertarget{ssclme_8c_a15}{
\index{ssclme.c@{ssclme.c}!ssclme_sigma@{ssclme\_\-sigma}}
\index{ssclme_sigma@{ssclme\_\-sigma}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-sigma]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-sigma (SEXP {\em x}, SEXP {\em REML})}\hfill}
\label{ssclme_8c_a15}


Extract the ML or REML conditional estimate of sigma

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em REML}]logical scalar - TRUE if REML estimates are requested\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]numeric scalar \end{Desc}
\hypertarget{ssclme_8c_a33}{
\index{ssclme.c@{ssclme.c}!ssclme_to_lme@{ssclme\_\-to\_\-lme}}
\index{ssclme_to_lme@{ssclme\_\-to\_\-lme}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-to\_\-lme]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-to\_\-lme (SEXP {\em call}, SEXP {\em facs}, SEXP {\em x}, SEXP {\em model}, SEXP {\em REML}, SEXP {\em rep}, SEXP {\em fitted}, SEXP {\em residuals}, SEXP {\em terms}, SEXP {\em assign})}\hfill}
\label{ssclme_8c_a33}


Create an lme object from its components. This is not done by new(\char`\"{}lme\char`\"{}, ...) at the R level because of the possibility of causing the copying of very large objects.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em call}]Pointer to the original call \item[{\em facs}]pointer to the list of grouping factors \item[{\em x}]pointer to the model matrices (may be of length zero) \item[{\em model}]pointer to the model frame \item[{\em REML}]pointer to a logical scalar indicating if REML is used \item[{\em rep}]pointer to the converged ssclme object \item[{\em fitted}]pointer to the fitted values \item[{\em residuals}]pointer to the residuals \item[{\em terms}]pointer to a terms object (redundant if model is non-empty) \item[{\em assign}]pointer to an integer assign vector\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]an lme object \end{Desc}
\hypertarget{ssclme_8c_a5}{
\index{ssclme.c@{ssclme.c}!ssclme_transfer_dimnames@{ssclme\_\-transfer\_\-dimnames}}
\index{ssclme_transfer_dimnames@{ssclme\_\-transfer\_\-dimnames}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-transfer\_\-dimnames]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-transfer\_\-dimnames (SEXP {\em x}, SEXP {\em facs}, SEXP {\em mmats})}\hfill}
\label{ssclme_8c_a5}


Copy the dimnames from the list of grouping factors and the model matrices for the grouping factors into the appropriate parts of the ssclme object.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em facs}]pointer to a list of factors \item[{\em mmats}]pointer to a list of model matrices\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]NULL \end{Desc}
\hypertarget{ssclme_8c_a6}{
\index{ssclme.c@{ssclme.c}!ssclme_update_mm@{ssclme\_\-update\_\-mm}}
\index{ssclme_update_mm@{ssclme\_\-update\_\-mm}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-update\_\-mm]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-update\_\-mm (SEXP {\em x}, SEXP {\em facs}, SEXP {\em mmats})}\hfill}
\label{ssclme_8c_a6}


Update the numerical entries x, Zt\-X, and Xt\-X in an ssclme object according to a set of model matrices.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object \item[{\em facs}]pointer to a list of grouping factors \item[{\em mmats}]pointer to a list of model matrices\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]NULL \end{Desc}
\hypertarget{ssclme_8c_a31}{
\index{ssclme.c@{ssclme.c}!ssclme_variances@{ssclme\_\-variances}}
\index{ssclme_variances@{ssclme\_\-variances}!ssclme.c@{ssclme.c}}
\paragraph[ssclme\_\-variances]{\setlength{\rightskip}{0pt plus 5cm}SEXP ssclme\_\-variances (SEXP {\em x})}\hfill}
\label{ssclme_8c_a31}


Return the unscaled variances

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em x}]pointer to an ssclme object\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]a list similar to the Omega list with the unscaled variances \end{Desc}
\hypertarget{ssclme_8c_a25}{
\index{ssclme.c@{ssclme.c}!unconstrained_gradient@{unconstrained\_\-gradient}}
\index{unconstrained_gradient@{unconstrained\_\-gradient}!ssclme.c@{ssclme.c}}
\paragraph[unconstrained\_\-gradient]{\setlength{\rightskip}{0pt plus 5cm}static void unconstrained\_\-gradient (SEXP {\em grad}, SEXP {\em Omega})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{ssclme_8c_a25}


Overwrite a gradient with respect to positions in Omega\mbox{[}\mbox{[}i\mbox{]}\mbox{]} by the gradient with respect to the unconstrained parameters.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em grad}]pointer to a gradient wrt positions. Contents are overwritten. \item[{\em Omega}]pointer to a list of symmetric matrices (upper storage). \end{description}
\end{Desc}
\hypertarget{ssclme_8c_a26}{
\index{ssclme.c@{ssclme.c}!upperTriList_to_vector@{upperTriList\_\-to\_\-vector}}
\index{upperTriList_to_vector@{upperTriList\_\-to\_\-vector}!ssclme.c@{ssclme.c}}
\paragraph[upperTriList\_\-to\_\-vector]{\setlength{\rightskip}{0pt plus 5cm}static void upper\-Tri\-List\_\-to\_\-vector (SEXP {\em m\-List}, int $\ast$ {\em nc}, SEXP {\em cvec})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}\hfill}
\label{ssclme_8c_a26}


Fills cvec with unlist(lapply(m\-List, function(el) el\mbox{[}upper.tri(el, strict = FALSE)\mbox{]}))

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em m\-List}]pointer to a list of REAL matrices \item[{\em nc}]number of columns in each matrix \item[{\em cvec}]pointer to REAL vector to receive the result \end{description}
\end{Desc}
