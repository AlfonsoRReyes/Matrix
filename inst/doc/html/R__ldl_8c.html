<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Matrix: R_ldl.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>R_ldl.c File Reference</h1><code>#include "<a class="el" href="R__ldl_8h-source.html">R_ldl.h</a>"</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="R__ldl_8c.html#a0">R_ldl_symbolic</a> (int n, const int Ap[], const int Ai[], int Lp[], int Parent[], const int P[], int Pinv[])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="R__ldl_8c.html#a1">R_ldl_numeric</a> (int n, const int Ap[], const int Ai[], const double Ax[], const int Lp[], const int Parent[], int Li[], double Lx[], double D[], const int P[], const int Pinv[])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="R__ldl_8c.html#a2">R_ldl_lsolve</a> (int n, double X[], const int Lp[], const int Li[], const double Lx[])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="R__ldl_8c.html#a3">R_ldl_dsolve</a> (int n, double X[], const double D[])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="R__ldl_8c.html#a4">R_ldl_ltsolve</a> (int n, double X[], const int Lp[], const int Li[], const double Lx[])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="R__ldl_8c.html#a5">R_ldl_perm</a> (int n, double X[], const double B[], const int P[])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="R__ldl_8c.html#a6">R_ldl_permt</a> (int n, double X[], const double B[], const int P[])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="R__ldl_8c.html#a7">R_ldl_valid_perm</a> (int n, const int P[])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="R__ldl_8c.html#a8">R_ldl_valid_matrix</a> (int n, const int Ap[], const int Ai[])</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a3" doxytag="R_ldl.c::R_ldl_dsolve"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void R_ldl_dsolve           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>D</em>[]</td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
solve Dx=b<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>L is n-by-n, where n &gt;= 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>size n. right-hand-side on input, soln. on output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>D</em>&nbsp;</td><td>diagonal elements of size n </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="R_ldl.c::R_ldl_lsolve"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void R_ldl_lsolve           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Lp</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Li</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>Lx</em>[]</td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
solve Lx=b<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>L is n-by-n, where n &gt;= 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>size n. right-hand-side on input, soln. on output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Lp</em>&nbsp;</td><td>column pointer array of size n+1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Li</em>&nbsp;</td><td>row index array of size lnz=Lp[n] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Lx</em>&nbsp;</td><td>non-zero off-diagonal elements (size lnz=Lp[n]) </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="R_ldl.c::R_ldl_ltsolve"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void R_ldl_ltsolve           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Lp</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Li</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>Lx</em>[]</td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
solve L'x=b<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>L is n-by-n, where n &gt;= 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>size n. right-hand-side on input, soln. on output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Lp</em>&nbsp;</td><td>column pointer array of size n+1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Li</em>&nbsp;</td><td>row index array of size lnz=Lp[n] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Lx</em>&nbsp;</td><td>non-zero off-diagonal elements (size lnz=Lp[n]) </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="R_ldl.c::R_ldl_numeric"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int R_ldl_numeric           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Ap</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Ai</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>Ax</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Lp</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Parent</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Li</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>Lx</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>D</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Pinv</em>[]</td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given a sparse matrix A (the arguments n, Ap, Ai, and Ax) and its symbolic analysis (Lp and Parent, and optionally P and Pinv), compute the numeric LDL' factorization of A or PAP'. The outputs of this routine are arguments Li, Lx, and D.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>A and L are n-by-n, where n &gt;= 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ap</em>&nbsp;</td><td>column pointer array of size n+1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ai</em>&nbsp;</td><td>row index array of size nz=Ap[n] (upper triangle only) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ax</em>&nbsp;</td><td>array of non-zero matrix elements of size nz=Ap[n] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Lp</em>&nbsp;</td><td>column pointer array of size n+1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Parent</em>&nbsp;</td><td>elimination tree of size n </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Li</em>&nbsp;</td><td>row index array of size lnz=Lp[n] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Lx</em>&nbsp;</td><td>non-zero off-diagonal elements of L (size lnz=Lp[n]) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>D</em>&nbsp;</td><td>vector of diagonal elements (size n) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>optional permutation vector of size n [use (int *) NULL for none] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Pinv</em>&nbsp;</td><td>optional inverse permutation [use (int *) NULL for none]</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>n if successful, k if D (k,k) is zero </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="R_ldl.c::R_ldl_perm"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void R_ldl_perm           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>[]</td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
permute a vector, x=Pb<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>size of X, B, and P </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>output of size n </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input of size n </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>input permutation array of size n </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="R_ldl.c::R_ldl_permt"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void R_ldl_permt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>[]</td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
permute a vector, x=P'b<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>size of X, B, and P </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>output of size n </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input of size n </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>input permutation array of size n </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="R_ldl.c::R_ldl_symbolic"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void R_ldl_symbolic           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Ap</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Ai</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Lp</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Parent</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Pinv</em>[]</td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The input to this routine is a sparse matrix A, stored in column form, and an optional permutation P. The output is the elimination tree and the number of nonzeros in each column of L. Parent [i] = k if k is the parent of i in the tree. The Parent array is required by R_ldl_numeric. Lnz [k] gives the number of nonzeros in the kth column of L, excluding the diagonal.<p>
If P is NULL, then it is ignored. The factorization will be LDL' = A. Pinv is not computed. In this case, neither P nor Pinv are required by R_ldl_numeric.<p>
If P is not NULL, then it is assumed to be a valid permutation. If row and column j of A is the kth pivot, the P [k] = j. The factorization will be LDL' = PAP', or A (p,p) in MATLAB notation. The inverse permutation Pinv is computed, where Pinv [j] = k if P [k] = j. In this case, both P and Pinv are required as inputs to R_ldl_numeric.<p>
The floating-point operation count of the subsequent call to R_ldl_numeric is not returned, but could be computed after R_ldl_symbolic is done. It is the sum of (Lnz [k]) * (Lnz [k] + 2) for k = 0 to n-1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>A and L are n-by-n, where n &gt;= 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ap</em>&nbsp;</td><td>column pointers of size n+1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ai</em>&nbsp;</td><td>row indices of size nz=Ap[n] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Lp</em>&nbsp;</td><td>column pointers of size n+1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Parent</em>&nbsp;</td><td>elimination tree of size n </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>optional permutation vector of size n [use (int *) NULL for none] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Pinv</em>&nbsp;</td><td>optional inverse permutation [not used if P is NULL] </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="R_ldl.c::R_ldl_valid_matrix"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int R_ldl_valid_matrix           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Ap</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>Ai</em>[]</td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine checks to see if a sparse matrix A is valid for input to R_ldl_symbolic and R_ldl_numeric. It returns 1 if the matrix is valid, 0 otherwise. A is in sparse column form. The numerical values in column j are stored in Ax [Ap [j] ... Ap [j+1]-1], with row indices in Ai [Ap [j] ... Ap [j+1]-1]. The Ax array is not checked.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>A is n by n (n &gt;= 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ap</em>&nbsp;</td><td>column pointer array of size n+1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ai</em>&nbsp;</td><td>row index array of size nz=Ap[n]</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>1 if valid sparse matrix, otherwise 0 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="R_ldl.c::R_ldl_valid_perm"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int R_ldl_valid_perm           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>[]</td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if a permutation vector is valid<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>size of permutation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>input of size n, a permutation of 0:n-1</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>1 if valid, otherwise 0 </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Mar 1 16:58:11 2005 for Matrix by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
